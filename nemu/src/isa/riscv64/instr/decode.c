#include "../local-include/reg.h"
#include <cpu/ifetch.h>
#include <isa-all-instr.h>
#include "../include/isa-def.h"

def_all_THelper();

static uint32_t get_instr(Decode *s)
{
  return s->isa.instr.val;
}

// decode operand helper
#define def_DopHelper(name) \
  void concat(decode_op_, name)(Decode * s, Operand * op, word_t val, bool flag)

static inline def_DopHelper(i)
{
  op->imm = val;
}

static inline def_DopHelper(r)
{
  bool is_write = flag;
  static word_t zero_null = 0;
  op->preg = (is_write && val == 0) ? &zero_null : &gpr(val);
}

static inline def_DopHelper(j)
{
  op->simm = 0;
  op->simm |= s->isa.instr.j.simm19_12 << 12;
  op->simm |= s->isa.instr.j.simm11 << 11;
  op->simm |= s->isa.instr.j.simm10_1 << 1;
  op->simm |= s->isa.instr.j.simm20 << 20;
  if (s->isa.instr.j.simm20 == 1)
  {
    op->simm -= (2 << 20);
  }
}

// TODO may occur bug
static inline def_DopHelper(b) {
  sword_t sval = 0;
  sval |= s->isa.instr.b.imm4_1 << 4;
  sval |= s->isa.instr.b.simm10_5 << 4;
  sval |= s->isa.instr.b.imm11 << 11;
  if(s->isa.instr.b.simm12 == 1) {
    sval -= (2 << 12);
  }
  // TODO using temporary reigister s0
  *s0 = sval;
}

// TODO add R type
// TODO may occur bug at bool flag
static inline def_DHelper(R) {
  decode_op_r(s, id_src1, s->isa.instr.r.rs1, false);
  decode_op_r(s, id_src2, s->isa.instr.r.rs2, false);
  decode_op_r(s, id_dest, s->isa.instr.r.rd, false);
}

static inline def_DHelper(I)
{
  //TODO may occur bug at bool flag
  decode_op_r(s, id_src1, s->isa.instr.i.rs1, false);
  decode_op_i(s, id_src2, (sword_t)s->isa.instr.i.simm11_0, false);
  decode_op_r(s, id_dest, s->isa.instr.i.rd, true);
}

static inline def_DHelper(S)
{
  decode_op_r(s, id_src1, s->isa.instr.s.rs1, false);
  sword_t simm = (s->isa.instr.s.simm11_5 << 5) | s->isa.instr.s.imm4_0;
  decode_op_i(s, id_src2, simm, false);
  decode_op_r(s, id_dest, s->isa.instr.s.rs2, false);
}

//TODO add B type
// TODO may occur bug at bool flag
static inline def_DHelper(B) {
  decode_op_b(s, 0, 0, false);
  decode_op_r(s, id_src1, s->isa.instr.b.rs1, true);
  decode_op_r(s, id_src2, s->isa.instr.b.rs2, true);
}

static inline def_DHelper(U)
{
  decode_op_i(s, id_src1, (sword_t)s->isa.instr.u.simm31_12 << 12, true);
  decode_op_r(s, id_dest, s->isa.instr.u.rd, true);
}

static inline def_DHelper(J)
{
  decode_op_j(s, id_src1, 0, true);
  decode_op_r(s, id_dest, s->isa.instr.j.rd, true);
}


def_THelper(load)
{
  def_INSTR_TAB("??????? ????? ????? 011 ????? ????? ??", ld);
  def_INSTR_TAB("??????? ????? ????? 010 ????? ????? ??", lw);
  return EXEC_ID_inv;
}

def_THelper(store)
{
  def_INSTR_TAB("??????? ????? ????? 011 ????? ????? ??", sd);
  return EXEC_ID_inv;
}
// r type
def_THelper(compute_r) {
  def_INSTR_TAB("0000000 ????? ????? 000 ????? ????? ??", add);
  def_INSTR_TAB("0100000 ????? ????? 000 ????? ????? ??", sub);
  return EXEC_ID_inv;
}
// i type 
def_THelper(compute_l)
{
  def_INSTR_TAB("??????? ????? ????? 000 ????? ????? ??", addi);
  def_INSTR_TAB("??????? ????? ????? 011 ????? ????? ??", sltiu);
  return EXEC_ID_inv;
}
// b type
def_THelper(branch) {
  def_INSTR_TAB("??????? ????? ????? 000 ????? ????? ??", beq);
  def_INSTR_TAB("??????? ????? ????? 001 ????? ????? ??", bne);
  return EXEC_ID_inv;
}

def_THelper(main)
{
  def_INSTR_IDTAB("??????? ????? ????? ??? ????? 00000 11", I, load);
  def_INSTR_IDTAB("??????? ????? ????? ??? ????? 01000 11", S, store);
  def_INSTR_IDTAB("??????? ????? ????? ??? ????? 00101 11", U, auipc);
  def_INSTR_IDTAB("??????? ????? ????? ??? ????? 00100 11", I, compute_l);
  def_INSTR_IDTAB("??????? ????? ????? ??? ????? 01100 11", R, compute_r);
  def_INSTR_IDTAB("??????? ????? ????? ??? ????? 11000 11", B, branch);

  def_INSTR_IDTAB("??????? ????? ????? ??? ????? 11011 11", J, jal);
  def_INSTR_IDTAB("??????? ????? ????? ??? ????? 11001 11", I, jalr);

  def_INSTR_TAB("??????? ????? ????? ??? ????? 11010 11", nemu_trap);
  return table_inv(s);
};

int isa_fetch_decode(Decode *s)
{
  s->isa.instr.val = instr_fetch(&s->snpc, 4);
  int idx = table_main(s);
  return idx;
}
